<?php


namespace Anexia\ParamParser\Parser;


use Anexia\ParamParser\Lexer\ParamLexer;
use Anexia\ParamParser\Lexer\ParamSequenceLexer;
use Anexia\ParamParser\Node\ParamNode;
use Anexia\ParamParser\Node\SequenceNode;
use Anexia\ParamParser\Token\Token;


/**
 * Class ParamSequenceParser
 *
 * Parses tokens of a param sequence expression. That is an expression that looks as follows:
 * "random-sequence{name:type:option1,option2,option3}other-random-sequence"
 *
 * @package Anexia\ParamParser\Parser
 */
class ParamSequenceParser extends AbstractParser
{

    /**
     * ParamSequenceParser constructor.
     *
     * @param ParamSequenceLexer $lexer  Lexer that produces the tokens for the parser.
     * @param int                $offset Offset to calculate absolute token position.
     */
    public function __construct(ParamSequenceLexer $lexer, int $offset)
    {
        parent::__construct($lexer, $offset);
    }

    /**
     * Parses the tokens generated by the lexer and returns an array of nodes representing the structure
     * of the expression. A node may be a {@link SequenceNode}, which represents a sequence of text without
     * any meaning, or may be a {@link ParamNode}, which represent a parameter with a name, optional type and
     * some options.
     *
     * @return array
     * @throws ParserSyntaxException
     */
    public function parse(): array
    {
        $nodeList     = [];
        $currentToken = $this->eat([Token::TYPE_EOF, Token::TYPE_SEQUENCE, Token::TYPE_LC_BRACKET]);

        while ($currentToken->getTokenType() !== Token::TYPE_EOF) {
            switch ($currentToken->getTokenType()) {
                case Token::TYPE_SEQUENCE:
                    $nodeList[] = new SequenceNode($currentToken->getTokenValue());
                    break;

                case Token::TYPE_LC_BRACKET:
                    $paramSequence     = $this->eat([Token::TYPE_SEQUENCE]);
                    $paramParser       = new ParamParser(
                        new ParamLexer($paramSequence->getTokenRawValue()),
                        $paramSequence->getTokenPosition() + $this->offset
                    );
                    $paramParserResult = $paramParser->parse();
                    $nodeList[]        = new ParamNode(
                        $paramParserResult[0],
                        $paramParserResult[1],
                        $paramParserResult[2]
                    );
                    $this->eat([Token::TYPE_RC_BRACKET]);
                    break;
            }

            $currentToken = $this->eat([Token::TYPE_EOF, Token::TYPE_SEQUENCE, Token::TYPE_LC_BRACKET]);
        }

        return $nodeList;
    }

}
